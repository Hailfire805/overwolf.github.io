---
id: game-events-specification
image: "/img/embed/api-best-practices.jpg"
title: Game Events Specification
---

Game events allow applications to truly understand what is happening in a game,
which in turn lets them deliver a significantly more accurate and adaptive experience.

There are two different forms of data that are referred to as `events`:
- [Game Events](#game-events) - Specific events that happen in the game.
- [Game Information](#game-info) (Game Info for short, formerly referred to as part of Info Updates) - The current state of specific parts of the game.

When a Game Event/Game Info occurs/changes, an event/info update is fired respectively, letting the app know of it.

## Game Events

Game events refer to the moment at which a notable event occurs in the game,
and are rarely relevant for more than a few seconds after they occur. Common examples include:
- Player kill
- Player assist
- Item obtained
- Achievement unlocked

<details>
<summary>Example Event</summary>

```json title="A player just scored 5 points"
{
    "name": "score",
    "data": {
        "score": 5,
        "player": "User123"
    }
}
```

</details>

## Game Info

Game Info refers to a persistent game state. Common examples include:
- Player name
- Player health
- Player inventory
- Current match

Game Info is stored in categories, that are then stored in a dictionary-like object, accessible to applications via the [`overwolf.games.events.getInfo()`](/api/games/events#getinfocallback) method.
Every Game Info item exists inside of a single category, and categories cannot be nested.

<details>
<summary>Example Game Info Layout</summary>

```json title="An example Game Info layout, containing 3 categories, and 5 total Game Info items"
{
    "category_1": {
        "item_info": "Example string",
        "reset_info": null
    },
    "category_2": {
        "number_info": 125,
        "object_info": {
            "inner_foo": "value",
            "inner_bar": true
        }
    },
    "player_inventory": {
        "coins": 55
    }
}

```

</details>

### Info Updates

Info Update events fire when a change occurs in a certain Game Info, with the new value of that specific Game Info.

<details>
<summary>Example Info Updates</summary>

```json title="A match just started, updating the match_state game info inside of the match_info category"
{
    "match_info": {
        "match_state": {
            "in_progress": true,
            "match_id": 12512
        }
    }
}
```

```json title="The player's coin count changed to 5, updating the coins info inside of the player_inventory category"
{
    "player_inventory": {
        "coins": 5
    }
}
```

</details>

### Info Resetting

Info updates are events. However, they are not fired directly. They are fired when their specific Game Info changes.

As such, in order to ensure that these events fire properly, even if the exact value might not have changed, event "resets" are used.
This is done by changing the value to a consistent, clearly invalid value (usually `null`), as soon as it becomes irrelevant.
Then, once the new value should be set, it is set, and a new event is fired.

The reset can then be ignored by the app, by being detected as a reset, and then the new value can be handled as a fresh update.

<details>
<summary>Example Reset</summary>

Assume that we have a `score`` Game Info. This value is set to 0 at the start of every match.

```json title="First match just started, score was set to 0"
...
    "score": 0
...
```

Now, it could be possible that a match will end with `score` still being set to 0. As a result, when the next match starts,
setting `score` to 0 will not fire an event.

To stop that from happening, when the match ends, we set `score`, and any other match-specific data, to null:

```json title="First match just ended, score is set to null"
...
    "score": null
...
```

Now, when the next match will start, score will change from null to 0, causing an event to fire.

```json title="Second match just started, score is set to 0"
...
    "score": 0
...
```

</details>

## Features

:::note Game Events SDK and Features
Currently, the [game events SDK](/topics/integrations/events-sdk-for-game-developers) does not natively support features.

- For game developers using the SDK - This means that this section is redundant.
- For app developers - This means that SDK games will fire **all** game events, meaning that you can skip the [`setRequiredFeatures()`](/api/games/events#setrequiredfeaturesfeatures-callback) step.
:::

Both Game Events and Game Info are grouped into `features`. Features serve as a way to group events based on their purpose. For example:
- `match_info` - Information about the current match.
- `death` - Death counters + Player death event.
- `abilities` - Events fired when the player uses an ability + Current ability levels.

An application then subscribes to the specific features it needs using [`setRequiredFeatures()`](/api/games/events#setrequiredfeaturesfeatures-callback), and is only notified of those events.

:::tip Game Info And Features
Game Info category names will usually correspond to the relevant feature's name.
:::

## Events Convention

In order to ensure that events stay consistent accross games, we have set a few guidelines in place.
These guidelines serve as the baseline for any new events introduced from now on, regardless of their origin.

:::note Older Events
In order to ensure backwards compatiability is maintained, any events published before this document will stay as they are
for the forseeable future.
:::

### Naming Convention

Event/Feature naming should always follow these guidelines:

<details>
<summary>All event and inner variable names should be written in snake_casing</summary>

- Do's:
    - `player`
    - `match_info`
    - `team_round_win`
    - `roster`
- Don't do's:
    - `Player`
    - `matchinfo`
    - `teamRoundWin`
    - `team_Set`
    - `Score_board`

You can read more [here](https://en.wikipedia.org/wiki/Snake_case).

</details>

<details>
<summary>Events names should be informative</summary>

- Do's:
    - `abilities`
    - `roster`
    - `local_player`
- Don't Do's:
    - `used`
    - `connected`
    - `me`

</details>

<details>
<summary>Event names should use existing names and structures where appropriate</summary>

There are many events that occur in a similar way across many different games.
In order to keep a unified workflow, the same names should be used to describe the same workflows, where possible.

Furthermore, in many cases, the same event structure can be used for several different events.

<details>
<summary>Example of multiple similar events</summary>

The `killed` event structure can be used:
- For player vs player battles, where one player is killed by another player.
- For when a mob monster is killed (by a player, or another mob monster).
- Or for any other case where one entity is killed by another entity.

In that case, there would be several different events, all based on the `killed` event structure:
- `player_kill` - A player was killed.
- `monster_kill` - A monster was killed.
- Any other event in which a distinct entity type who's death should be tracked was killed.

The exact distinction naming scheme will depend on the event "recipe", as well as the individual case.

</details>

<details open>
<summary>Common Game Events</summary>

<details open>
<summary>match_start/match_end</summary>

Game Events denoting the start/end of a match, with any relevant data (information about the current match/the match's result).

A match in this context, is defined as a game between any number of set teams or individuals, without any breaks that take the players
out of the game.

For example:
- A best of 5 game of control points is a single match.
- However, if in between every one of those games, the players were taken out of the game, to the game's launcher, for a potentially unknown amount of time,
each one of those games would be one match.

</details>

<details open>
<summary>round_start/round_end</summary>

Game Events denoting the start/end of a round, with any relevant data (information about the current round/the round's result).

A round in this context, is defined as a subset of a match, as defined above.

For example:
- A best of 5 game of control points will include up to five matches.
- However, if in between every one of those games, the players were taken out of the game, to the game's launcher, for a potentially unknown amount of time,
there would be no round event.

</details>

<details open>
<summary>killed</summary>

Game Event fired when an entity is killed by another entity, with any potential number of assisting entities.

This can include any of the following (depending on the use-case), as well as any extra information required:
- `killer` - An object containing:
    - `id` - Identifier of the main killer
    - `method` - Information about the method used for the kill by the main killer
- `assist` - An array of any number of objects containing:
    - `id` - Identifier of the assisting entity
    - `method` - Information about the method used for the assist
- `killed` - An object containing:
    - `id` - Identifier of the killed entity

</details>

<details open>
<summary>game_mode</summary>

//TODO

</details>

<details open>
<summary>damage</summary>

//TODO

</details>

</details>

<details open>
<summary>Game Info</summary>

<details open>
<summary>roster</summary>

The roster **category** contains all of the information about all of the players in the match that is known to the local client.

<details open>
<summary>roster_&#123;id&#125;</summary>

A single entry per player in the match (either current, initial, total, or "discovered"), with each entry using the player's unique {id} in its entry name.
Each entry can then include any of the following (depending on the use-case):
- `username` - The player's username
- `team_identifier` - An identifier of the player's team
- `class`/`role` - The player's class/role details
- `is_local` - Is this the local player
- Any other player-specific data

</details>

- `players` - An array of all player ids that currently have an info entry in the roster category
- `current_player_count` - Amount of currently "active" players in the match
- `initial_player_count` - Amount of players that were initially active in the match

</details>

<details open>
<summary>game_info</summary>

The `game_info` category contains general information about the game as a whole.

<details open>
<summary>scene</summary>

The scene Game Info contains general information about the current scene of the game/that the local player is in.

This is usually just a simple string name of the current scene. Common example values include:
- loading - Loading the game
- main_menu - The main menu
- lobby - In a lobby
- loading_match - Loading the specific match
- in_match - Inside a match
- post_match - Post match scene, while potentially transferring back to the lobby

</details>

</details>

</details>

</details>

### Types Convention

:::note
This section is only relevant for game developers, as it discusses the exact formats for sending game data.
:::

In order to ensure a smoother integration for all sides involved, we have compiled a list of different data types and their preferred formats:

Raw Type            | Serialized Format | Note                |
--------------------| ------------------| --------------------|
[resets](info-resetting) | null         |                     |
boolean             | boolean           |                     |
integers            | integer           |                     |
floats              | TBD               |                     |
real-world time     | unix timestamp in milliseconds | Timestamps for real-world times |
aplhanumeric values | string            | Enum names or other constant values that include letters |
user-generated text | string (base64)   | Usernames, chat, and anything else that could include complex characters |
array[]             | array[]           | Arrays should be kept as arrays, while their values should all recursively comply with the convention |
object              | object            | Objects should be kept the same where possible, and their values should all recursively comply with both the naming and the value convention |