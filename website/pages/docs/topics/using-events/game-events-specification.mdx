---
id: game-events-specification
image: "/img/embed/api-best-practices.jpg"
title: Game Events Specification
---

Game events allow applications to truly understand what is happening in a game,
which in turn lets them deliver a significantly more accurate and adaptive experience.

<SkipMe>
### Note for anyone reading this
This spec is a WIP, and as such, some parts of it are "commented out" for now, in the SkipMe components.
Anything you see under it is not necessarily going to make it into the final thing, and might just be remnants of older versions!
</SkipMe>

There are two different forms of data that are referred to as `events`:
- [Game Events][game-events] - Specific events that happen in the game.
- [Game Information][game-info] (Game Info for short, also referred to as part of Info Updates) - The current state of specific parts of the game.

When a Game Event/Info occurs/changes, an event/info update is fired respectively, letting the app know of it.

However, in order to make this data easy to expose and use, we have created the following specification.

<SkipMe>
:::tip TL;DR
The most important take-away from this specification is the following:
- This spec is a general guideline for any Game Event implementations from the moment of its full adoption. However, due to technical limitations, some implementations might have to stray away from it.
In those cases, they will detail the difference in their documentation.
- Game Events should mostly be used to notify of important momentary changes and their UID.
- Game Info should mostly be used for exposing any data of actual importance from the game.
    - Game Info should be used to expose the data related to specific Game Events.
    - Game Info exposing data of specific Game Events should be occassionally deleted, when a predefined set of declared conditions occur,
    in order to avoid clutter/resource hogging.
- Not all game data should be exposed as events, but events **can** be used to notify an app of external data sources (files, external API keys, etc).
- Events planning can be tricky, with many different approaches being valid, and many potential pitfalls along the way.
As such, do not hesitate to [contact us](/support/contact-us) for help with the design process.
:::

</SkipMe>

## Game Events

Game events refer to the moment at which a notable event occurs in the game,
and are meant to notify an app of its exact moment. Common examples include:
- Entity `killed`
- Item `obtained`
- Achievement `unlocked`
- Scene `changed`

Game events offer a way for an app to detect the exact moment at which something happened, even before all of its data (if any) is ready/exposed to the app/player.

### Event Contents

<SkipMe>
All Game Events will always contain the following reserved fields:
- `momentary` - Whether this is a `Momentary Game Event`, or a `Deferred Game Event`.
- 'initial_timestamp' - The computer-local [timestamp (in milliseconds)](https://currentmillis.com/) when the event was initially fired.
</SkipMe>

There are two types of Game Events, each with their own kinds of data:
- Momentary Game Event - For momentary Game Events, where no follow-up is desried, and there is absolutely no use for keeping a log.
<SkipMe>
    - The Game Event will always set the reserved `momentary` field to true. 
    - The Game Event will contain the rest of its data under the `data` property.
</SkipMe>
- Deferred Game Event - For deferred Game Events, where follow-up can happen, or there is a use for keeping a log:
    - The Game Event's `data` property will contain the field `id`, which is equal to a Unique Identifier ([`uid`](#game-event-uid)) of the event.

<SkipMe>
    - The Game Event will always set the reserved `momentary` field to false.
</SkipMe>

By doing that, it makes it possible:
- For apps to have a "moving window" of relevant past events, rather than needing to keep a copy of every fired event.
- For games to easily expose new information about old occurances as it becomes available to the player, while keeping the entire thing cleanly linked together, using familiar workflows.

#### Game Event UID

A "complete" Deferred Game Event Unique ID (`uid`) is made up of two parts:
- The event's type - `event_name`
- An ID for this specific event, unique from within this type of event - `id`

As a result, every Deferred Game Event only needs to send the event's `uid` as its data.

The event `uid` should be consistently formatted throughout the entire game where possible (although more than one format can be used if necessary),
and should always use one of the following `uid` patterns:

```js title="Event UID Schemas ((${event_name}-) added to results for readability)"
// When exposing the exact event count + order easily is desirable
`${numerical_index}` = '(scored-)0', '(round_phase-)4'
/* When exposing the exact event count + order is not desirable, the index will simply
be randomized for every event, while ensuring it is unique among the currently stored events */
`${random_index}` = '(scored-)1261125', '(round_phase-)215192'
/* When exposing the event order is desirable, but not the count, the index will simply
be randomized every time an **in-game** event occurs, and the event fired once it should be */
`${randomly_incrementing_index}` = '(scored-)126125', '(round_phase-)215192'
// When further splitting of the event id is desirable, but the event itself should not be split
`${filter}-${some_indexing}` = '(scored-)blue-0', '(round_phase-)build-12412582'
```


<details>
<summary>Example Event</summary>

```json title='A player was just killed, with the kill id of "9"'
{
    "name": "player_killed",
    "data": {
        "id": "9"
    }
}
```

</details>

## Game Info

Game Info refers to an object-like piece of exposed game data. Common examples include:
- `player` data
- `killed` data
- Game meta-data (game version, game platform, game server)

Game Info offers a way for an app to access a read-only version of exposed hierarchical game data, checking it at will, and being notified when it changes.

### Game Info Contents

Game Info is stored inside of categories (dictionaries), that are then all stored in the GameInfo dictionary, accessible to applications via the [`overwolf.games.events.getInfo()`](/api/games/events#getinfocallback) method.
Every Game Info item exists only inside of a single category, and categories cannot be nested.

Game Info items are split into two types, and will always follow their type's structure format:
- General Game Info - For general Game Info that is not related to any specific Game Event.
    - The category name will always be either the Feature name, or part of a list of [reserved category names][reserved-categories].
    - The Game Info name will always correspond to the Game Info name given to it under its relevant [feature](#features).
- Game Event Data - For Game Info that corresponds to a certain Game Event:
    - The category name will always be the exact event name of the original event.
    - The Game Info name will always correspond to one of three values (see example event data):
        - The full `uid` of the [Game Event UID](#game-event-uid).
        - The reserved name `log`, and contain a dictionary of `uid` -> values.
        - The first section of the `uid`, and contain a dictionary of the remaining `uid` parts -> values.

<SkipMe>
    - The Game Info will always contain the reserved `initial_timestamp` field, containing the computer-local [timestamp (in milliseconds)](https://currentmillis.com/) the event was initially fired.
    - The Game Info will always contain the reserved `final` field, indicating whether or not the Game Info has been finalized (meaning that it will not be changed anymore).
</SkipMe>


<details>
<summary>Example Game Info Layout</summary>

```json title="An example Game Info layout, containing 3 categories, and 5 total Game Info items"
{
    "category": { // category 1
        "item_info": "Example string", // info 1 - General Game Info
        "reset_info": null // info 2 - General Game Info
    },
    "game_event": { // category 2 - the different forms of deferred event data
        "9": { // info 3 - Game Event Data, of event uid = 9
            "inner_foo": "value",
            "inner_bar": true
        },
        "log": { // info 4 - Game Event Data, containing uids = [10, 11]
            "10": "value",
            "11": true
        },
        "blue": { // info 3 - Game Event Data, containing uids = [blue-12, blue-13]
            "12": "value",
            "13": true
        },
    },
    "local_player": { // category 3
        "number_info": 125 // info 4 - General Game Info
        "boolean_info": true // info 5 - General Game Info
    }
}
```

</details>

### Info Updates

Info Updates (Game Info change events) fire when a change occurs in a certain Game Info, and contain the new value of that specific Game Info.

<details>
<summary>Example Info Updates</summary>

```json title="Example General Game Info - The blue team has just scored 5 points, increasing their score count from 8 to 13, while red is still at 18"
{
    "match_info": {
        "score": {
            "blue": 13,
            "red": 18
        }
    }
}
```

```json title="Example Game Event Data - The blue team has just scored 5 points, making this the 3rd time they have scored in the game"
{
    "scored": {
        "blue-3": {
            ...
            "scorer": "player_1"
            ...
        }
    }
}
```

</details>

### Game Event Data Clearing

Game Event Data, by its definition, will slowly accumulate with every new Game Event with data that fires.

As such, in order to ensure that this is stopped before a serious performance impact is reached, older Game Event Data occassionally has to be removed from its dictionary.
The conditions for clearing should always be included in the specification for those Game Events. Common examples include:
- Only the last x (=50|100|7|...) Game Event Data of a certain Game Event (like `killed`) is kept, and the rest of the data for that Game event will be automatically discarded.
- Game Event Data for a certain Game Event (like `score`) is cleared every time a certain Game Event is fired (like `match_end`)

This way, even if data will be cleared, apps can know exactly when it will be cleared, and can make sure to copy parts of it that they require.

### Game Info Resetting

Info updates are events. However, they are not fired directly. They are fired when their specific Game Info changes.

As such, in order to ensure that these events fire properly, even if the exact value represented might not have changed, event "resets" are used.
This is done by changing the value to a consistent, clearly invalid value (usually `null`), as soon as it becomes irrelevant.
Then, once the new value should be set, it is set, and a new event is fired.

Every General Game Info that can be reset then includes the cases, as well as the values, of its resets.
The resets can then be detected and ignored by apps, and then the new value can be handled as a fresh update.

<details>
<summary>Example Reset</summary>

Assume that we have a `score`` Game Info. This value is set to 0 at the start of every match.

```json title="First match just started, score was set to 0"
...
    "score": 0
...
```

Now, it could be possible that a match will end with `score` still being set to 0. As a result, when the next match starts,
setting `score` to 0 will not fire an event.

To stop that from happening, when the match ends, we set `score`, and any other match-specific data, to null:

```json title="First match just ended, score is set to null"
...
    "score": null
...
```

Now, when the next match will start, score will change from null to 0, causing an event to fire.

```json title="Second match just started, score is set to 0"
...
    "score": 0
...
```

</details>

## Features

:::note Game Events SDK and Features
Currently, the [game events SDK](/topics/integrations/events-sdk-for-game-developers) does not natively support `features`.

- For game developers using the SDK - This means that this section is redundant.
- For app developers - This means that SDK games will fire **all** game events, meaning that you can skip the [`setRequiredFeatures()`](/api/games/events#setrequiredfeaturesfeatures-callback) step.
:::

Both Game Events and Game Info are part of `features`. Features serve as a way to group events based on their purpose. For example:
- `match_info` - All events related to information about the current match.
- `score` - All information related to a match's score, including when someone `scored`.
- `death` - Death counters + Player death event.
- `abilities` - Events fired when the player uses an ability + Current ability levels.

An application then subscribes to the specific features it needs using [`setRequiredFeatures()`](/api/games/events#setrequiredfeaturesfeatures-callback), and is only notified of those events.

:::tip Game Info And Features
Game Info category names interact with features in two ways:
- For Game Info corresponding to a Game Event, the category name will be that of the original event, not the feature.
- For General Game Info, depneding on the type of information, it will sit under either:
    - A category named after the relevant feature.
    - One of the few [reserved category names][reserved-categories].
:::

## Events Convention

In order to ensure that events stay consistent accross games, we have set a few guidelines in place.
These guidelines serve as the baseline for any new events introduced from now on, regardless of their origin.

:::note Older Events
In order to ensure backwards compatiability is maintained, any events published before this document will stay as they are
for the forseeable future.
:::

### Naming Convention

Event/Feature naming should always comply with the following guidelines:

<details>
<summary>All event and inner variable names should be written in snake_casing</summary>

- Do's:
    - `player`
    - `match_info`
    - `team_round_win`
    - `roster`
- Don't do's:
    - `Player`
    - `matchinfo`
    - `teamRoundWin`
    - `team_Set`
    - `Score_board`
    - `MaTcHeNd`
    - ...

You can read more [here](https://en.wikipedia.org/wiki/Snake_case).

</details>

<details>
<summary>Events names should be informative</summary>

- Do's:
    - `abilities`
    - `roster`
    - `local_player`
- Don't Do's:
    - `used`
    - `connected`
    - `me`

</details>

<details>
<summary>Event names should use existing names and structures where appropriate</summary>

There are many events that occur in a similar way across many different games.
In order to keep a unified workflow, the same names should be used to describe the same workflows, where possible.

Furthermore, in many cases, the same event structure can be used for several different events.

<details>
<summary>Example of multiple similar events</summary>

The `killed` event structure can be used:
- For player vs player battles, where one player is killed by another player.
- For when a mob monster is killed (by a player, or another mob monster).
- Or for any other case where one entity is killed by another entity.

In that case, there would be several different events, all based on the `killed` event structure:
- `player_killed` - A player was killed.
- `monster_killed` - A monster was killed.
- Any other event in which a distinct entity type who's death should be tracked individually was killed.

In cases where multiple event variants exist of a single event structure, they should all be named as follows:

`${distinguishing_factor}_${event_structure_name}`

</details>

<details open>
<summary>Common Game Events</summary>

<details open>
<summary>match_start/match_end</summary>

Game Events denoting the start/end of a match, with any relevant data (information about the current match/the match's result).

A match in this context, is defined as a game between any number of set teams or individuals, without any breaks that take the players
out of the game.

For example:
- A best of 5 game of control points is a single match.
- However, if in between every one of those games, the players were taken out of the game, to the game's launcher, for a potentially unknown amount of time,
each one of those games would be one match.

</details>

<details open>
<summary>round_start/round_end</summary>

Game Events denoting the start/end of a round, with any relevant data (information about the current round/the round's result).

A round in this context, is defined as a subset of a match, as defined above.

For example:
- A best of 5 game of control points will include up to five matches.
- However, if in between every one of those games, the players were taken out of the game, to the game's launcher, for a potentially unknown amount of time,
there would be no round event.

</details>

<details open>
<summary>killed</summary>

Game Event fired when an entity is killed by another entity, with any potential number of assisting entities.

This can include any of the following (depending on the use-case), as well as any extra information required:
- `killer` - An object containing:
    - `id` - Identifier of the main killer
    - `method` - Information about the method used for the kill by the main killer
- `assist` - An array of any number of objects containing:
    - `id` - Identifier of the assisting entity
    - `method` - Information about the method used for the assist
- `killed` - An object containing:
    - `id` - Identifier of the killed entity

</details>

<details open>
<summary>game_mode</summary>

//TODO

</details>

<details open>
<summary>damage</summary>

//TODO

</details>

</details>

<details open>
<summary>Game Info</summary>

<details open>
<summary>roster</summary>

The roster **category** contains all of the information about all of the players in the match that is known to the local client.

<details open>
<summary>roster_&#123;id&#125;</summary>

A single entry per player in the match (either current, initial, total, or "discovered"), with each entry using the player's unique {id} in its entry name.
Each entry can then include any of the following (depending on the use-case):
- `username` - The player's username
- `team_identifier` - An identifier of the player's team
- `class`/`role` - The player's class/role details
- `is_local` - Is this the local player
- Any other player-specific data

</details>

- `players` - An array of all player ids that currently have an info entry in the roster category
- `current_player_count` - Amount of currently "active" players in the match
- `initial_player_count` - Amount of players that were initially active in the match

</details>

<details open>
<summary>game_info</summary>

The `game_info` category contains general information about the game as a whole.

<details open>
<summary>scene</summary>

The scene Game Info contains general information about the current scene of the game/that the local player is in.

This is usually just a simple string name of the current scene. Common example values include:
- loading - Loading the game
- main_menu - The main menu
- lobby - In a lobby
- loading_match - Loading the specific match
- in_match - Inside a match
- post_match - Post match scene, while potentially transferring back to the lobby

</details>

</details>

</details>

</details>

### Types Convention

:::note
This section is only relevant for game developers, as it discusses the exact formats for sending game data.
:::

In order to ensure a smoother integration for all sides involved, we have compiled a list of different data types and their preferred formats:

Raw Type            | Serialized Format | Note                |
--------------------| ------------------| --------------------|
[resets](info-resetting) | null         |                     |
boolean             | boolean           |                     |
integers            | integer           |                     |
floats              | TBD               |                     |
real-world time     | unix timestamp in milliseconds | Timestamps for real-world times |
aplhanumeric values | string            | Enum names or other constant values that include letters |
user-generated text | string (base64)   | Usernames, chat, and anything else that could include complex characters |
array[]             | array[]           | Arrays should be kept as arrays, while their values should all recursively comply with the convention |
object              | object            | Objects should be kept the same where possible, and their values should all recursively comply with both the naming and the value convention |





[game-events]: #game-events
[game-info]: #game-info
[reserved-categories]: TODO