---
id: game-events-specification
image: "/img/embed/api-best-practices.jpg"
title: Game Events Specification
---

Game events allow applications to truly understand what is happening in a game,
which in turn lets them deliver a significantly more accurate and adaptive experience.

There are two different forms of data that are referred to as `events`:
- [Game Events](#game-events) - Specific events that happen in the game.
- [Game Information](#game-info) (Game Info for short, formerly referred to as part of Info Updates) - The current state of specific parts of the game.

When a Game Event occurs, or a Game Info changes, an event or info update is fired respectively, letting the app know of it.

## Game Events

Game events refer to the moment at which a notable event occures in the game,
and are rarely relevant for more than a few seconds after they occur. Common examples include:
- Player kill
- Player assist
- Item obtained
- Achievement unlocked

<details>
<summary>Example Event</summary>

```json title="A player just scored 5 points"
{
    "name": "score",
    "data": {
        "score": 5,
        "player": "User123"
    }
}
```

</details>

## Game Info

Game Info refers to a persistent game state. Common examples include:
- Player name
- Player health
- Player inventory
- Current match

Game Info is stored in categories, that are then stored in a dictionary-like object, accessible to applications via the [`overwolf.games.events.getInfo()`](/api/games/events#getinfocallback) method.
Every Game Info item exists inside of a single category, and categories cannot be nested.

<details>
<summary>Example Game Info Layout</summary>

```json title="An example Game Info layout, containing 3 categories, and 5 total Game Info items"
{
    "category_1": {
        "item_info": "Example string",
        "reset_info": null
    },
    "category_2": {
        "number_info": 125,
        "object_info": {
            "inner_foo": "value",
            "inner_bar": true
        }
    },
    "player_inventory": {
        "coins": 55
    }
}

```

</details>

### Info Updates

Info Update events fire when a change occures in a certain Game Info, with the new value of that specific Game Info.

<details>
<summary>Example Info Updates</summary>

```json title="A match just started, updating the match_state game info inside of the match_info category"
{
    "match_info": {
        "match_state": {
            "in_progress": true,
            "match_id": 12512
        }
    }
}
```

```json title="The player's coin count changed to 5, updating the coins info inside of the player_inventory category"
{
    "player_inventory": {
        "coins": 5
    }
}
```

</details>

### Info Resetting

Info updates are events. However, they are not fired directly. They are fired when their specific Game Info changes.

As such, in order to ensure that these events fire properly, even if the exact value might not have changed, event "resets" are used.
This is done by changing the value to a consistent, clearly invalid value (usually `null`), as soon as it becomes irrelevant.
Then, once the new value should be set, it is set, and a new event is fired.

The reset can then be ignored by the app, by being detected as a reset, and then the new value can be handled as a fresh update.

<details>
<summary>Example Reset</summary>

Assume that we have a `score`` Game Info. This value is set to 0 at the start of every match.

```json title="First match just started, score was set to 0"
...
    "score": 0
...
```

Now, it could be possible that a match will end with `score` still being set to 0. As a result, when the next match starts,
setting `score` to 0 will not fire an event.

To stop that from happening, when the match ends, we set `score`, and any other match-specific data, to null:

```json title="First match just ended, score is set to null"
...
    "score": null
...
```

Now, when the next match will start, score will change from null to 0, causing an event to fire.

```json title="Second match just started, score is set to 0"
...
    "score": 0
...
```

</details>

## Features

:::note Game Events SDK and Features
Currently, the [game events SDK](/topics/integrations/events-sdk-for-game-developers) does not natively support features.

- For game developers using the SDK - This means that this section is redundant.
- For app developers - This means that SDK games will fire **all** game events, meaning that you can skip the [`setRequiredFeatures()`](/api/games/events#setrequiredfeaturesfeatures-callback) step.
:::

Both Game Events and Game Info are grouped into `features`. Features serve as a way to group events based on their purpose. For example:
- `match_info` - Information about the current match.
- `death` - Death counters + Player death event.
- `abilities` - Events fired when the player uses an ability + Current ability levels.

An application then subscribes to the specific features it needs using [`setRequiredFeatures()`](/api/games/events#setrequiredfeaturesfeatures-callback), and is only notified of those events.

:::tip Game Info And Features
Game Info category names will usually correspond to the relevant feature's name.
:::

## Events Convention

In order to ensure that events stay consistent accross games, we have set a few guidelines in place.
These guidelines serve as the baseline for any new events introduced from now on, regardless of their origin.

:::note Older Events
In order to ensure backwards compatiability is maintained, any events published before this document will stay as they are
for the forseeable future.
:::

### Naming Convention

Event/Feature naming should always follow these guidelines:

<details>
<summary>All event and inner variable names should be written in snake_casing</summary>

- Do's:
    - `player`
    - `match_info`
    - `team_round_win`
    - `roster`
- Don't do's:
    - `Player`
    - `matchinfo`
    - `teamRoundWin`
    - `team_Set`
    - `Score_board`

You can read more [here](https://en.wikipedia.org/wiki/Snake_case).

</details>

<details>
<summary>Events names should be informative</summary>

- Do's:
    - `abilities`
    - `roster`
    - `local_player`
- Don't Do's:
    - `used`
    - `connected`
    - `me`

</details>

<details>
<summary>Event names should use existing names where appropriate</summary>

There are many events that occur in a similar way across many different games.
In order to keep a unified workflow, the same names should be used to describe the same workflows, where possible.

### Game Events

<details open>
<summary>match_start/match_end</summary>

**Game Events** denoting the start/end of a match, with any relevant data (information about the current match/the match's result).

A match in this context, is defined as a game between any number of set teams or individuals, without any breaks that take the players
out of the game.

For example:
- A best of 5 game of control points is a single match.
- However, if in between every one of those games, the players were taken out of the game, to the game's launcher,
each one of those games would be one match.

</details>

<details open>
<summary>round_start/round_end</summary>

**Game Events** denoting the start/end of a round, with any relevant data (information about the current round/the round's result).

A round in this context, is defined as a subset of a match, as defined above.

For example:
- A best of 5 game of control points will include up to five matches.
- However, if in between every one of those games, the players were taken out of the game, to the game's launcher,
there would be no round event.

</details>

<details open>
<summary>scene</summary>



</details>

<details open>
<summary>kill</summary>



</details>

<details open>
<summary>assist</summary>



</details>

<details open>
<summary>death</summary>



</details>

<details open>
<summary>game_mode</summary>



</details>

<details open>
<summary>damage</summary>



</details>

### Game Info

<details open>
<summary>roster</summary>

A roster **Game Info** will contain all of the information about all of the players in the match that is known to the local client.

This can include any of the following (depending on the use-case):
- Array of players (either current, initial, total, or "discovered") that each details:
    - `username` - The player's username
    - `team_identifier` - An identifier of the player's team
    - `class`/`role` - The player's class/role details
    - `is_local` - Is this the local player
    - Any other player-specific data
- `current_player_count` - Amount of currently "active" players in the match
- `initial_player_count` - Amount of players that were initially active in the match

</details>

</details>

### Types Convention

:::note
This section is only relevant for game developers, as it discusses the exact formats for sending game data.
:::

In order to ensure a smoother integration for all sides involved, we have compiled a list of different data types and their preferred formats:

Raw Type            | Serialized Format | Note                |
--------------------| ------------------| --------------------|
[resets](info-resetting) | null         |                     |
boolean             | boolean           |                     |
integers            | integer           |                     |
floats              | TBD               |                     |
real-world time     | unix timestamp in milliseconds | Timestamps for real-world times |
aplhanumeric values | string            | Enum names or other constant values that include letters |
user-generated text | string (base64)   | Usernames, chat, and anything else that could include complex characters |
array[]             | array[]           | Arrays should be kept as arrays, while their values should all recursively comply with the convention |
object              | object            | Objects should be kept the same where possible, and their values should all recursively comply with both the naming and the value convention |